# --------- FROM FPGA --------------------------------------------

#read_result = fpga.read_frame(0x00, 1)
#print(f"FPGA Version: {read_result[0]}")

# PARAMETERS
address = 0x400
number_of_words = 1024
#write_values = [*range(0,1024)]
write_values = [-2]*number_of_words
print(f"Write Values: {write_values}")

# BEFORE WRITE
read_result_before = fpga.read_frame (address, number_of_words)
print(f"BRAM Before:  {read_result_before}")

# AFTER WRITE
fpga.write_frame (address, write_values)
read_result_after = fpga.read_frame (address, number_of_words)
print(f"BRAM After:   {read_result_after}")


def compareResults(write_values, read_result_after):
    if (write_values == read_result_after):
        return "PASS"
    else:
        return "FAIL"

print(f"Words: {number_of_words}")
print(f"Test:  {compareResults(write_values,read_result_after)}")

# --------------------------------------------------------------------


import random
import time
import sys

x = [1,2,4,3]
y = [*range(1,5)]



d = [1]*3
#print(d)
start = 1
end = 4
step = 1

section_of_list = slice(start,end,step)

print (x[section_of_list])



# ---------------------------RANDOMIZING MEMORY CODE-----------------------------------------


# number_of_words = 1024                                          # total number of words is half of generated bytes
# num_of_bytes = number_of_words*2                                # must be even number of bytes 
# random_bytes = random.randbytes(num_of_bytes)                   # random 8 bit chunks

# byte_list = [x for x in random_bytes]                           # creates list of integer form of each 8 bit chunk

# # then add every two adjacent elements of the list

# result = []
# index = 0
# while index < number_of_words: 
    
#     even_elment = 2*index
#     index += 1                   
#     two_elements = slice(even_elment,even_elment + 2)           
#     integer_list = byte_list[two_elements]                      # choosing adjacent elements
#     concat_byte = (integer_list[0] << 8) + integer_list[1]      # concatenate numbers before putting them in list
#     result.append(concat_byte)

# -------------------------------------------------------------------------------------------

# this whole thing needs to be in a for loop that determines how long you want the test to go
random_number_of_words = random.randint(0,1023) # how many words
random_words = [random.randint(0,65535) for n in range(random_number_of_words)]  # what the words say, 2^16 - 1 possible numbers for 16 bits
random_address = random.randint(0,1023) # where the start address is
adress_segement = random_number_of_words + random_address
address_space = 1024
overflow = 0

print(random_address)
print("address before =",random_address)
print("number of words before =", random_number_of_words)
print("random_number_of_words + random_addr = ", random_number_of_words + random_address)

# Wrap around address space process
if adress_segement > address_space:
    overflow = abs(random_number_of_words - random_address) # new number of words starting at address 0
    number_of_words = overflow
    address = 0
    read_result_overflow = fpga.read_frame (address, number_of_words)

# read_result.append()

print("address after =",random_address)
print("number of words after =", random_number_of_words)
print("overflow =", overflow)

read_or_write = random.randint(0,1)

# if read_or_write == 1:
# 	fpga.write_frame(address,number_of_words)
# else:
# 	result = fpga.write_frame(address,number_of_words)

# concatenate the wrapped around read to the read at the end
for i in read_result_overflow:
    read_result.append(i)









# ------------------------------------NOTES-----------------------------------------------------

# - you need to separate the read/write when there is a wrap around

# - this will mean sending a new read/write/ instruction so add a sleep(0.05) between these

# - the write data will need to be sliped into the part written at the end of the memory and 
#   the part wrapped around at the beginning (the overflow)

# - when doing a read (actually comparing the data to test for accuracy) that wraps around, you'll need to
#   put the read_result_overflow and read_result together before comparing to ref_data

# - you still need to build a representation of the memory to store all the writes at the correct addresses on the
#   PC side of things to be saved for comparisons on read cycles

# - you need to make a comparison happen ONLY on a read cycle (50% of the time)

# - you should probably write something that will record all of the results of the comparisons
















# -------------------------------------------------------------------------------------------

# Parameters to test: variable write lengths, variable read lengths, variable start locations

# make 3 functions for each



# variable length is number_of_words (address locations) 1-1024

# start + number of words = cannot exceed 1024

# if start + number of words > 1024 then subtract 1024 by number and use that number to subtract off the total number of words

ref_data = [0]*1024 # initializes data list

#def wr_data(write_values):








#addr_list = [*range(1024)] # creates list of all addressses, need to map data entry to each address

#data_list = []
#write = ___

#if write == 1:
#    addr_list[n]
#    stored_data = data_list[n]
